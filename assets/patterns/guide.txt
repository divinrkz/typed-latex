let $:Mset Min Mgreater_than Mgreater_than_or_equal Mless_than Mless_than_or_equal:^be arbitrary
(choose|consider|define)$:Mequal Mnot_equal:, 
(suppose|assume|let) (that)?$:Mequal Mnot_equal:, 

splits by: 
space
    ?
        () 
            or ||


in first split container expressions and type defining expressions {? -> Option, string -> Word, progression -> Sequence, }

let $
(choose|consider|define)$
let$
(let)$
and (let)?
and (let)?$
(suppose|assume|let)(that)?
define$
(choose|consider|define)((an|a)arbitrary)?$
(choose|consider|define)( (an|a|some))?
(choose|consider|define)( (an|a|some)(arbitrary)?)?$
(such that|where|with)
^there (exists (an|a|some)|is (an|a)|exist[^s])
^there (exists)( (an|a|some))?$
there (is|exists|exist) ((an|a|some))?$
there exists( (an|a|some))?
there (are|exists|exist)(( )?(a|an|some)?)
there (exists (an|a|some)|is (an|a)|exist[^s])
case
(by|go by|do) ((((structural|strong) )?induction)|induct) (over|on)$
for some( arbitrary)?$
for some( )?$
for (all|every|any)
(for (all|every|any))$
for some ?$
^there (exists (an|a|some)|is (an|a)|exist[^s])
^there (exists)( (an|a|some))?$
there (is|exists|exist)( (an|a|some))?$
there (are|exists|exist)(( )?(a|an|some)?)
choose|consider|define)( (an|a|some))?
for (all|every|any)$n


str = "let $"
split by space: ["let", "$"]
for each str
    if str is not string: pass
    else is string check if there is a ? at the end:
        if yes, open Optional remove the ? and
            if || split and add to Anys each word checker
    else 
        word checker
        \
what happens when the word is a space.
for now M == Mvar














let$:(Mset Min Mgreater_than Mgreater_than_or_equal Mless_than Mless_than_or_equal)?:^be arbitrary


let$
    let$ -> clean_word Word let$
(Mset Min Mgreater_than Mgreater_than_or_equal Mless_than Mless_than_or_equal)?
 if () has ?
  Any
    Mset
    Min
    Mgreater_than
    Mgreater_than_or_equal
    Mless_than
else 
    []
    

^be arbitrary
   ^be -> clean word be 
    arbitrary -> clean word arbitrary










let$:Mvar:^(be|represent) (an|a|any|some)? arbitrary (,)?:D 

Sequence [ 
    Word "let"; 
    DefContainer (MathPattern (Expression 2), 1); 
    Any [Word "be"; Word "represent"]; 
    Optional (Any ["an"; "any"; "some"]);
     Word "arbitrary"; 
     Optional (Word ",");
     DefContainer (MathPattern (Expression 3), 4)
]


let$:(Mset|Min|Mgreater_than|Mgreater_than_or_equal|Mless_than|Mless_than_or_equal):^be arbitrary

Sequence [
    Word "let";
    Any [   
            DefContainer (MathPattern (Function "Mset", [Expression 6, Expression 7]), 5)];
            DefContainer (MathPattern (Function "Min", [Expression 6, Expression 7]), 5)];
            DefContainer (MathPattern (Function "Mgreater_than", [Expression 6, Expression 7]), 5)];
            DefContainer (MathPattern (Function "MgreatMgreater_than_or_equaler_than", [Expression 6, Expression 7]), 5)];
            DefContainer (MathPattern (Function "Mless_than", [Expression 6, Expression 7]), 5)];
            DefContainer (MathPattern (Function "Mless_than_or_equal", [Expression 6, Expression 7]), 5)]
        ]
    Word "be";
    Word "arbitrary"
    ]


there (is|exists|exist) (an|a|some)?$:Mvar:^((,)? such that|where|with)$:Mvar
Sequence [
    Word "there";
    Any [Word "is"; Word "exists"; Word "exist];
    Optional (Any [Word "an"; Word "a"; Word "some]);
    DefContainer (MathPattern (Expression 1), 8);
    Optional (Word ",");
    Any [Word "such that"; Word "where"; Word "with"];
    DefContainer (MathPattern (Expression 1), 8);
]

for (all|every|any)$:Mvar:^in (the)?:D 
define$:Mvar:^to be ((an|any|some) (arbitrary)?)?:D

Sequence [
    Word "define";
    DefContainer (MathPattern (Expression 1), 8);
    Word "to";
    Word "be";
    Optional (Sequence [Any [Word "an"; Word "any"; Word "some"]; Optional (Word "arbitrary)])
    DefContainer (MathPattern (Expression 1), 8);
]

